/*
 *	miaofng@2011 initial version
 */
#include "config.h"
#include "ulp/debug.h"
#include "ulp_time.h"
#include "dbs.h"
#include "sis_card.h"
#include <string.h>

#define CONFIG_DBS_LEARN 1

static enum {
	DBS_STM_INIT,
	DBS_STM_BLACK,	/*comm blackout pedriod, DBS_BLK_MS*/
	DBS_STM_TRACE1,	/*1st group of 8 trace message + DBS_IMG_MS*/
	DBS_STM_TRACE2,	/*2nd group of 8 trace message + DBS_IMG_MS*/
	DBS_STM_OK,	/*2 ok message + DBS_OKD_MS*/
	DBS_STM_FAULT,	/*continous fault message*/
	DBS_STM_ACC,	/*continous acc message*/
	DBS_STM_ACC_UPDATE,
	DBS_STM_ERROR,	/*dbs itself hardware error*/
#ifdef CONFIG_DBS_LEARN
	DBS_LEARN_BLACK, /*comm blackout pedriod, DBS_BLK_MS*/
	DBS_LEARN_BUSY,
	DBS_LEARN_PASS,
	DBS_LEARN_FAIL,
#endif
} dbs_stm = DBS_STM_INIT;
static time_t dbs_timer;
#define DBS_FIFO_SIZE (4096) //10mS buffer * 8000msg/1S * (19 + 2)bit/msg * 2edge/bit = 3360
static unsigned short dbs_fifo[DBS_FIFO_SIZE];
static unsigned short dbs_size = 0; //fifo fize
static struct dbs_sensor_s dbs_sensor;

/*polynom = x^5 + x^2 + 1, 100101 = 0x25
31bits = 26bits + 5bits*/
static unsigned crc5(unsigned v)
{
	int i, mask, p = 0x25;
	v <<= 5; //26 + 5 = 31
	for(i = 25; i >= 0; i--) {
		mask = 1 << (i + 5);
		if(v & mask) {
			v ^= (p << i);
			//printf("v = 0x%04x, p = 0x%04x i = %02d\n", v, p, i);
		}
	}
	return v;
}

/*note:
 1, bits[18, 0] is effective input bits, and send out msb first
 2, encoder size output will fold back to 0, if dbs_fifo overflow
 3, encoder time output will fold back to 0, if time bigger than 65535
 4, give out a time point to dbs_fifo when an edge occurs
 5, set init = 1 to do fifo init operation before encode
 */
int dbs_encode(int bits, int init)
{
	int i, mask, bit_new, bit_old = -1;
	unsigned short time;

	if(init) {
		dbs_size = 0;
		memset(dbs_fifo, 0, sizeof(dbs_fifo));
	}

	time = dbs_fifo[dbs_size];
	for(i = 18; i >= 0; i --) {
		mask = 1 << i;
		bit_new = (bits & mask) ? 1 : 0;

		time = time + 0;
		if((bit_new == bit_old) && (bit_old != -1)) {
			dbs_fifo[dbs_size] = time;
			dbs_size = (dbs_size != DBS_FIFO_SIZE) ? (dbs_size + 1) : 0;
		}

		time = time + 1;
		if(!((time == 1) && (init == 1))) {
			//ignore upgoing edge of first start bit, it won't be generated by DMA
			dbs_fifo[dbs_size] = time;
			dbs_size = (dbs_size != DBS_FIFO_SIZE) ? (dbs_size + 1) : 0;
		}

		time = time + 1;
		bit_old = bit_new;
	}

	//add two idle bits at the msg tail
	time = time + 0;
	if(bit_old == 0) {
		dbs_fifo[dbs_size] = time;
		dbs_size = (dbs_size != DBS_FIFO_SIZE) ? (dbs_size + 1) : 0;
	}

	time = time + 4;
	dbs_fifo[dbs_size] = time;
	//note: do not increase dbs_size here!!!

	return 0;
}

void dbs_init(struct dbs_sensor_s *sensor, void *cfg)
{
	int div = (1 << (sensor->speed - 1));
	div *= 205; //72MHz / 205 / 2 = 5.694uS, 8000mps => T=5.35~5.95uS
	card_player_init(5, 25, div);
	memcpy(&dbs_sensor, sensor, sizeof(dbs_sensor));
	dbs_stm = DBS_STM_INIT;
	dbs_timer = 0;
}

void dbs_update(void)
{
	union dbs_msg_s msg;
	int i;

	//wait?
	if(time_left(dbs_timer) > 0)
		return;

	switch(dbs_stm) {
	case DBS_STM_INIT:
		dbs_stm = DBS_STM_BLACK;
		dbs_timer = time_get(DBS_BLK_MS);
		break;
	case DBS_STM_BLACK:
		dbs_stm = DBS_STM_TRACE1;
		dbs_timer = time_get(DBS_IMG_MS);
		break;
	case DBS_STM_TRACE1:
	case DBS_STM_TRACE2:
		for(i = 0; i < 8; i ++) {
			msg.value = 0;
			msg.trace.start = 0x00; //0b00;
			msg.trace.type = 0x00; //0b00;
			msg.trace.addr = dbs_sensor.addr;
			msg.trace.data = dbs_sensor.trace[i];
			msg.trace.crc = crc5(msg.value >> 8);
			dbs_encode(msg.value >> 3, i == 0);
		}
		card_player_start(dbs_fifo, dbs_size, 0);
		while(card_player_left() > 0);
		card_player_stop();
		dbs_stm = (dbs_stm == DBS_STM_TRACE1) ? DBS_STM_TRACE2 : DBS_STM_OK;
		if(dbs_stm == DBS_STM_OK) {
			dbs_stm = (dbs_sensor.mode == 1) ? DBS_STM_ACC : DBS_STM_OK;
		}
		dbs_timer = time_get(DBS_IMG_MS);
		break;
	case DBS_STM_OK: //note: stm will stay at this state!!!
		msg.value = 0;
		msg.soh.start = 0x00; //0b00;
		msg.soh.type = 0x00; //0b00;
		msg.soh.d98 = 0x00; //0b00;
		msg.soh.addr = dbs_sensor.addr;
		msg.soh.data = SOH_OK;
		msg.soh.crc = crc5(msg.value >> 8);
		dbs_encode(msg.value >> 3, 1);
		dbs_encode(msg.value >> 3, 0); //two continuous OK msg
		card_player_start(dbs_fifo, dbs_size, 0);
		while(card_player_left() > 0);
		card_player_stop();
		dbs_stm = DBS_STM_OK;
		dbs_timer = time_get(DBS_OKD_MS);
		break;
	case DBS_STM_FAULT:
	case DBS_STM_ACC:
		msg.value = 0;
		msg.acc.start = 0x00; //0b00;
		msg.acc.type = dbs_sensor.addr;
		msg.acc.data = 0x000; //0b00;
		msg.acc.crc = crc5(msg.value >> 8);
		dbs_encode(msg.value >> 3, 1);
		card_player_start(dbs_fifo, dbs_size, 1); //repeat mode
		dbs_stm = DBS_STM_ACC_UPDATE;
		break;
	case DBS_STM_ACC_UPDATE:
		break;
	case DBS_STM_ERROR:
	default:
		break;
	}
}

void dbs_poweroff(void)
{
	card_player_stop();
}

/* dbs learn:
	1) capture 500mS data or enough data(> DBS_LEARN_SIZE)
	2) analysis tracebility data
*/
#ifdef CONFIG_DBS_LEARN

static const char dbs_us[5][2] = {
	{05, 48}, //8000-1000mps
	{05, 06}, //8000mps	T=5.35~5.95uS
	{10, 12}, //4000mps	T=10.7~11.9uS
	{21, 24}, //2000mps	T=21.3~23.8uS
	{42, 48}, //1000mps	T=42.8~47.6uS
};

/*get speed info( = smallest upgoing edge interval) */
static int dbs_learn_speed(struct dbs_sensor_s *sensor, int n)
{
	int i, us;
	int min, cnt, us_min, us_max;
	char speed = DBS_SPEED_INVALID;

	us_min = dbs_us[0][0];
	us_max = dbs_us[0][1];
	min = us_max;
	do {
		//find smallest interval
		for(i = 1; i < n; i ++) {
			us = dbs_fifo[i] - dbs_fifo[i - 1];
			if((us < us_min) || (us > us_max))
				continue;

			if(us < min) {
				min = us;
				cnt = 0;
			}

			cnt += (us == min) ? 1 : 0;
		}

		//is it an approprite interval?
		if(cnt > 16) {
			for(i = 1; i < 5; i ++) {
				if((min >= dbs_us[i][0]) && (min <= dbs_us[i][1])) {
					speed = i;
					break;
				}
			}

			if(i < 5)
				break;
			else
				us_min = min;
		}
	} while(us_min <= us_max);

	if(speed != DBS_SPEED_INVALID) {
		sensor -> speed = speed;
		return 0;
	}

	return -1;
}

/*decode a dbs msg each time*/
static int dbs_learn_decode(union dbs_msg_s *msg, int n, int speed)
{
	int us, us_min, us_max;
	int w, bits = 0, stm = 0, nbits = 1; /*n = 1 => start bit 0 has been received*/
	int crc, ret = -1;

	do {
		w = -1;
		dbs_size ++;
		us = dbs_fifo[dbs_size] - dbs_fifo[dbs_size - 1];
		us = (us < 0) ? (us + 0x10000) : us;

		//us in 2T range?
		us_min = dbs_us[speed][0];
		us_max = dbs_us[speed][1];
		if((us >= us_min) && (us <= us_max))
			w = 2;

		//us in 3T range
		us_min = us_min + (us_min >> 1);
		us_max = us_max + ((us_max + 1) >> 1);
		if((us >= us_min) && (us <= us_max))
			w = 3;

		//us in 4T range?
		us_min = dbs_us[speed][0] << 1;
		us_max = dbs_us[speed][1] << 1;
		if((us >= us_min) && (us <= us_max))
			w = 4;

		//us bigger than 4T?
		if(us > us_max)
			w = 5;

		if(us < 0) {
			//a noise, decode fail ...
			return -1;
		}

		//manchester decode state machine
		if(stm == 0) {
			if(w == 2) { //0 received
				bits <<= 1;
				bits |= 0x00;
				nbits ++;
				stm = 0;
			}
			else if(w == 3) {//11 received
				bits <<= 2;
				bits |= 0x03;
				nbits += 2;
				stm = 1;
			}
			else if(w == 4) {//10 received
				bits <<= 2;
				bits |= 0x02;
				nbits += 2;
				stm = 0;
			}
			else
				break;
		}
		else {
			if(w == 2) { //1 received
				bits <<= 1;
				bits |= 0x01;
				nbits ++;
				stm = 1;
			}
			else if(w == 3) { //0 received
				bits <<= 1;
				bits |= 0x00;
				nbits ++;
				stm = 0;
			}
			else
				break;
		}
	} while(dbs_size < n);

	if(nbits == 18) { //last received 1, it only has down going edge
		bits <<= 1;
		bits |= 0x01;
		nbits ++;
	}

	if(nbits == 19) {
		msg -> value = bits << 3;
		crc = bits & 0x1f;
		if(crc == crc5(bits >> 5))
			ret = 0;
	}

	return ret;
}

void dbs_learn_init(void)
{
	card_recorder_init(NULL);
	memset(dbs_fifo, 0, sizeof(dbs_fifo));
	dbs_size = 0;
	dbs_timer = time_get(DBS_BLK_MS_MIN);
	dbs_stm = DBS_LEARN_BLACK;
	memset(&dbs_sensor, 0, sizeof(dbs_sensor));
}

void dbs_learn_update(void)
{
	int i, n;
	if(dbs_stm == DBS_LEARN_BLACK) {
		if(time_left(dbs_timer) < 0) {
			card_recorder_start(dbs_fifo, DBS_FIFO_SIZE, 1);
			dbs_stm = DBS_LEARN_BUSY;
			dbs_timer = time_get(500); //capture 500mS
		}
		return;
	}

	if(dbs_stm != DBS_LEARN_BUSY)
		return;

	n = DBS_FIFO_SIZE - card_recorder_left();
	if((time_left(dbs_timer) > 0) && (n < 512)) {
		return;
	}

	card_recorder_stop();
	if(n < 20) {
		dbs_stm = DBS_LEARN_FAIL;
		return;
	}

	if(dbs_learn_speed(&dbs_sensor, n) < 0) {
		dbs_stm = DBS_LEARN_FAIL;
		return;
	}
	if(n > 500)
		dbs_sensor.mode = 1;

#if 1
	//print
	for(i = 1; i < n; i ++) {
		int us = dbs_fifo[i] - dbs_fifo[i - 1];
		us = (us < 0) ? 0x10000 + us : us;
		if(us > (1 << (dbs_sensor.speed - 1)) * 6 * 2) {
			printf("\n%05d: ", dbs_fifo[i - 1]);
		}
		printf("%02d ", us);
	}
#endif

	dbs_sensor.addr = 15;
	for(i = 0; i < 8; i ++) {
		union dbs_msg_s msg;
		if(dbs_learn_decode(&msg, n, dbs_sensor.speed))
			break;
		if(msg.trace.type != 0x00)
			break;

		if(dbs_sensor.addr > 3)
			dbs_sensor.addr = msg.trace.addr;
		else if(msg.trace.addr != dbs_sensor.addr)
			break;

		dbs_sensor.trace[i] = msg.trace.data;
	}

	dbs_stm = (i == 8) ? DBS_LEARN_PASS : DBS_LEARN_FAIL;
	return;
}

int dbs_learn_finish(void)
{
	return ((dbs_stm == DBS_LEARN_PASS) || (dbs_stm == DBS_LEARN_FAIL));
}

int dbs_learn_result(struct dbs_sensor_s *sensor)
{
	int ret = -1;
	if(dbs_stm == DBS_LEARN_PASS) {
		memcpy(sensor, &dbs_sensor, sizeof(dbs_sensor));
		ret = 0;
	}
	return ret;
}
#endif
